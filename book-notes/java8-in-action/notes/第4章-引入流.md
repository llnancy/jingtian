### 第四章：引入流
#### 1 流的定义
从支持数据处理操作的源生成的元素序列。

##### 1.1 元素序列
就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。

因为集合是数据结构，所以它的主要目的是以特定的时间/空间复杂度存储和访问元素（如ArrayList 与 LinkedList）。

但流的目的在于表达计算，比如前面见到的filter、sorted和map。

集合讲的是数据，流讲的是计算。

##### 1.2 源
流会使用一个提供数据的源，如集合、数组或输入/输出资源。

请注意，从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。

##### 1.3 数据处理操作
流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作，

如filter、map、reduce、find、match、sort等。流操作可以顺序执行，也可并行执行。 

#### 2 流操作的特点
##### 2.1 流水线
很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。

这让之后章节中的一些优化成为可能，如延迟和短路。

流水线的操作可以看作对数据源进行数据库式（链式）查询。

##### 2.2 内部迭代
与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的（内部迭代）。

##### 2.3 流只能被消费一次
终止操作只能有一次，重复消费会抛出java.lang.IllegalStateException异常。

#### 对流的操作分为两类：中间操作和终止操作
- 中间操作总是会惰性执行：执行一个中间操作不会在原流上做任何处理，而是创建一个标记了该操作的新流返回。
- 终止操作才会进行真实的计算：计算发生时会把所有中间操作积攒的操作以Pipeline的方式执行，这样可以减少迭代次数，计算完成后流即失效。

#### 集合与流的不同点：
- 无存储：Stream不是一种数据结构，它只是某种数据源的一个视图。数据源可以是一个数组、Java容器或I/O资源等。
- 为函数式编程而生：对Stream的任何修改都不会修改背后的数据源，比如对一个流执行filter过滤操作并不会删除被过滤的元素，而是会产生一个新的不包含被过滤元素的新流。
- 惰性执行：对流的中间操作并不会立即执行，只有等一个终止操作来临时才会一次性全部执行。
- 可消费性：一个流只能被消费一次，一旦产生终止操作，流即被消费。

### 本章小结
1. 流是“从支持数据处理操作的源生成的一系列元素”。
2. 流利用内部迭代：迭代通过filter、map、sorted等操作被抽象掉了。
3. 流操作有两类：中间操作和终端操作。
4. filter和map等中间操作会返回一个流，并可以链接在一起。可以用它们来设置一条流水线，但并不会生成任何结果。
5. forEach和count等终端操作会返回一个非流的值，并处理流水线以返回结果。
6. 流中的元素是按需计算的。