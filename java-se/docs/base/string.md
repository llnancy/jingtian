## 前言

在`Java`开发中，我们从头至尾都在与`String`打交道。还记得我们敲下的第一行代码吗？

```java
System.out.println("Hello World!");
```

> 这是我们所有开发人员梦开始的地方。那年，青涩的我们在课堂上敲下这第一行代码，殊不知，它竟会影响我们每个人的一生。

## `java.lang.String`类简介

对于部分刚学习`Java`的初学者来说，当问到`Java`中有哪些基本数据类型时，可能会回答出`String`字符串。

但事实上，`String`是一个引用类型。

> `Java`中的基本类型有以下八种：`byte`、`short`、`int`、`long`、`char`、`float`、`double`和`boolean`。

## `==`和`equals()`区别

我们先来看这样一段代码：

```java
public static void main(String[] args) {
	String a = "Hello" + " World" + "!";
	String b = "Hello World!";
	System.out.println(a == b);
}
```

聪明的你是否已经知道了这段代码的运行结果呢？

运行结果：`true`。

如果你立刻知道了结果且懂其原理，那么这一个知识点可以跳过；如果还有一点含糊，那就请仔细往下看。

要解释这个运行结果的原理，需要知道下面三个问题：

- `==`和`equals()`是如何进行比较的？
- 上述代码中的变量`a`和`b`在内存中是什么样的？
- 编译时的优化方案。

### `==`的比较方案

在`Java`语言中，`==`运算符用于比较两个内存单元上的内容是否一样，实际是比较两个数字，在计算机内部就是`0`和`1`。

对于七种基本数据类型（`boolean`除外），就是直接比较两者的数值是否相等。

而对于引用类型，例如示例中的`String`引用类型，比较的是“引用的值”，实际就是两者的内存地址值。

如果两个引用进行`==`比较，比较的是两个引用对象的内存地址值是否相等，实际上就是判断两个引用所指向的对象是否存储在同一个内存区域上。如果是，则返回`true`；否则返回`false`。

> 举一个不太恰当的比喻：大家都考上了心仪的大学，现在比较哪些人考上了同一所大学。

### `equals()`方法的比较方案

对于`equals()`方法，它的源头来自于`Object`类。在`Java`中，任何对象都隐式的继承了`java.lang.Object`类。所以任何对象都可以调用`equals()`方法进行比较。

而在`java.lang.Object`类中，`equals()`方法的实现是这样的：

```java
    public boolean equals(Object obj) {
        return (this == obj);
    }
```

直接使用了`==`运算符比较。这意味着：如果调用`equals()`方法进行比较的类及其显式使用`extends`关键字继承的父类列表中都没有重写过`equals()`方法，那么调用`equals()`方法就等同于使用`==`运算符进行比较。

`equals()`方法之所以存在于`Object`类中，就是希望子类去重写，以实现比较对象相等的功能。

`java.lang.String`类就重写了`equals()`方法，因为对于字符串来说，只要字符串内容相同，则可认为这两个字符串是“相等”的。

> 两个对象“相等”并不意味着对象的所有属性都要相等，需要根据对象的具体业务场景进行具体分析。
>
> 例如，两个罗技牌鼠标，它们的属性除了品牌、型号、尺寸和价格外，还有如生产地区、售卖方式等属性，但是我们可能只需要对比它们的品牌、型号和尺寸等属性，在这个范围内其余的属性不需关心。也就是说，两个对象的值是否相等需要根据对象的业务场景决定，而不是有一个唯一的标准来比较。
>
> 所以，`Object`类提供了`equals()`方法来让各个类选择重写，用以实现符合自身业务场景的对象相等比较。

### 上述代码中的变量`a`和`b`在内存中的结构

在`Java`中，对象在内存中的存储通常是：栈中的引用指向堆内的对象。对于字符串对象来说，还有一个字符串常量池用来存储字符串对象（它是一个`JVM`级别的字符串缓存），也就是会出现栈中的引用指向常量池中的对象。

> 在`Java6`之前，字符串常量池位于方法区内；
>
> 而在`Java7`中，字符串常量池被移到了堆内存中；
>
> 在`Java8`中，提出了元空间的概念，字符串常量池也随之移动到了元空间。

### 编译时的优化

变量`a`是通过`+`拼接字面量进行赋值的，在编译期，`String a = "Hello" + " World" + "!";`就已经被编译成`String a = "Hello World!";`了，为什么会这样呢？因为字面量的值是确定的，运行时不再需要任何计算，也就没有使用`+`运算符的必要了，编译器也这么觉得：“这不是在脱裤子放屁吗”？所以在编译期运算符就被去除了。于是`a`和`b`的赋值是完全一样的。

### 运行原理

对于变量`a`和`b`这种使用字面量创建字符串的方式，在创建变量`a`时，`JVM`首先会去字符串常量池中查找`"Hello World!"`这个字符串对象，如果不存在，则在字符串常量池中创建一个`"Hello World!"`对象，然后将常量池中`"Hello World!"`这个对象的引用地址赋给栈中的引用`a`，这样栈中的引用`a`就指向了常量池中的`"Hello World!"`对象；如果已经存在，则不会再次创建新对象，直接将已有的`"Hello World!"`对象的地址返回，赋给栈中的引用`b`，于是，栈中的引用`b`也指向了常量池中的`"Hello World!"`对象。

常量池中的`"Hello World!"`对象只有一份，于是使用`==`运算符比较变量`a`和`b`会返回`true`。

## 编译器的优化

我们再来看下面这段代码：

```java
    public static void main(String[] args) {
        String m = "a";
        final String n = "a";
        String x = m + "b";
        String y = n + "b";
        String z = getA() + "b";
        String compare = "ab";
        System.out.println(x == compare);
        System.out.println(y == compare);
        System.out.println(z == compare);
    }

    public static String getA() {
        return "a";
    }
```

你心中有答案吗？知道每个答案的原理吗？

如果还没有，下面的内容你应该仔细阅读。

输出结果：

```
false
true
false
```

首先，第一个输出，变量`x`与`compare`比较，变量`x`等于局部变量`m`加上字符串`"b"`，虽然局部变量`m`也指向了一个字面量`"a"`，但是这个引用关系并未进行“强制约束”，在运行期，可通过字节码增强技术来动态改变该引用的指向，所以编译器并未直接将其优化成`"ab"`。而是将其优化成了`StringBuilder`的形式：

```java
StringBuilder temp = new StringBuilder();
temp.append(m).append("b");
String x = temp.toString();
```

使用`new`关键字创建的`StringBuilder`对象位于堆内存中，于是变量`x`指向了堆中的对象。而局部变量`compare`指向字面量`"ab"`，按照前文的叙述，`JVM`将会先去字符串常量池寻找`"ab"`字符串对象，如果找到，则会直接返回常量池中地址返回，赋给引用`compare`。

变量`x`指向堆内存，而变量`compare`指向常量池内存，所以使用`==`运算符比较的结果为`false`。

第二个输出，变量`y`与`compare`比较，变量`y`等于局部变量`n`加上字符串`"b"`，虽然与变量`x`十分类似，但是，请注意局部变量`n`前面声明的`final`关键字，它具有不可变性，即`n`只会被赋值一次。保证了局部变量`n`始终指向字面量`"a"`所在的内存地址，按照程序的逻辑顺序，字面量`"a"`此时已经存在于字符串常量池中了，所以局部变量`n`始终指向常量池中`"a"`所在的内存地址。这个引用关系是无法进行修改的。所以编译器将变量`y`直接优化成了`"ab"`。

第三个输出，变量`z`与`compare`比较，变量`z`由一个方法的返回值加上字符串`"b"`组成，虽然方法内返回一个常量的引用，但是编译器并不会看方法内返回了什么，因为方法内部的行为是未知的，可能会出现多重递归，而且递归过后也不一定会返回固定的常量值。所以编译器不会将变量`z`优化成`"ab"`。

编译器的代码优化一定是在编译期就能确定优化后不会改变原有功能，类似于`final`引用，这个引用只会被赋值一次。只有在编译阶段能确定这个引用被赋值的内容，编译器才可能进行编译期优化，不要和运行期的动作关联到一起，编译期能确定的内容只来源于常量池，使用`new`关键字创建对象属于运行期的动作。同样地，方法的返回值也是不能确定的，运行期的方法可能会返回不同的值。

## `String#intern()`方法

有了上面的知识后，我们再来看以下代码：

```java
    public static void main(String[] args) {
        String a = "a";
        String b = a + "b";
        String c = "ab";
        String d = new String(b);
        System.out.println(b == c);
        System.out.println(c == d);
        System.out.println(c == d.intern());
        System.out.println(b.intern() == d.intern());
    }
```

这段代码增加了`intern()`方法的调用，其输出结果为：

```
false
false
true
true
```

对于前两个输出，你应该能知道答案。第一个输出在上一个例子中讲过了，输出为`false`；第二个输出，变量`c`在常量池中，变量`d`在堆中，输出为`false`。

对于后两个输出，如果你不了解`intern()`方法的作用，恐怕不能给出合理的解释。

当调用`String`类的`intern()`方法时，`JVM`会在常量池中通过`equals()`方法查找是否存在值相等的字符串，如果存在，则直接返回常量池中的地址；否则，则会将该字符串加入常量池（开辟新的内存空间），然后返回常量池中新开辟的这块内存空间地址。所以，只要是值相等（`equals()`方法比较相等）的字符串，当调用`intern()`方法时，都会得到常量池中对应字符串的引用地址，所以使用`==`运算符比较会返回`true`。

对于第三个输出，变量`c`使用字面量赋值，得到的是常量池中的引用；而变量`d`使用`new`关键字创建了一个堆中对象，但调用`intern()`方法后发现常量池中已经存在了`"ab"`，所以返回常量池的引用地址，于是使用`==`运算符比较返回`true`。

对于第四个输出，变量`b`和`d`都调用了`intern()`方法，得到的都是常量池中的引用地址，自然使用`==`运算符比较返回`true`。

## `StringBuilder`对象

在阿里巴巴开发手册中，推荐在`for`循环体内使用`StringBuilder`对象的`append()`方法进行字符串拼接，而不是`+`号。

手册中给出的反例如下：

```java
String str = "start";
for (int i = 0;i < 100;i++) {
	str = str + "hello";
}
```

由于没有给出正例，有些人在理解上可能出现了一些偏差，于是出现了以下代码：

```java
String str = "start";
for (int i = 0;i < 100;i++) {
    StringBuilder sb = new StringBuilder();
    sb.append(str)
      .append("hello");
	str = sb.toString();
}
```

实际上这也是反例，只不过是手册中给出的反例经过编译器编译之后的。

阿里巴巴的这个推荐的初衷是不要在循环体内使用`+`号，因为`+`号会被编译器优化成`StringBuilder`对象，所以它的建议实际是不要在循环体内创建`StringBuilder`对象。

正确的写法如下：

```java
StringBuilder sb = new StringBuilder();
String str = "start";
sb.append(str);
for (int i = 0;i < 100;i++) {
	sb.append("hello");
}
str = sb.toString();
```

为什么这样建议？使用`+`有什么不好的地方？

使用`+`号实际是在循环体内创建了`StringBuilder`对象，调用`append()`方法拼接后重新给引用`str`赋值，这会导致`str`指向的字符串越来越大，到达一定程度后会进入老年代，甚至出现`OOM`。同时每次循环都会创建一个`StringBuilder`对象，在一次循环结束后，该对象就会变成垃圾等待回收，导致内存开销增大。

而正确的写法会在循环体外预先创建一个`StringBuilder`对象，每次循环中都调用该对象的`append()`方法拼接字符串，避免了内存开销大的情况。

小结：要明确的一点是，不是`+`号操作本身慢，而是在循环体中每次循环都会创建对象导致内存开销变大，每一次循环后，创建的对象变成了垃圾引发`GC`进行垃圾回收，导致程序变慢。

## 总结

关于`String`类，本文只是抛砖引玉，很多细节并未提及，例如`StringBuilder`在进行`append`时的扩容，在拼接大字符串和小字符串时如何合理使用让内存利用率更高，还包括`StringBuffer`同步类等其它字符串相关的内容。总之，字符串是开发中必定会使用到的数据类型，如果涉及到字符串操作，请一定要考虑到效率问题，从小的细节入手精心雕琢代码。