有这样一道面试题。

面试官：“创建线程有哪几种方式？”；

面试者：“四种，第一是继承`Thread`类，第二是实现`Runnable`接口，第三是实现`Callable`接口创建具有返回值的线程，最后是通过线程池来创建线程。”

啊，多么标准的答案！

## 到底有几种方式呢？

这里不是想争辩说没有这四种，而是想谈谈我的一些理解。

首先我们来看`java.lang.Thread`类的类注释，有这样一段英文：

```text
 * There are two ways to create a new thread of execution. One is to
 * declare a class to be a subclass of <code>Thread</code>. This
 * subclass should override the <code>run</code> method of class
 * <code>Thread</code>. An instance of the subclass can then be
 * allocated and started. 
 
 ......
 
 * The other way to create a thread is to declare a class that
 * implements the <code>Runnable</code> interface. That class then
 * implements the <code>run</code> method. An instance of the class can
 * then be allocated, passed as an argument when creating
 * <code>Thread</code>, and started. 
 * <p>
```

很明显，`JDK` 的注释说明：`There are two ways to create a new thread of execution. One is to....The other way to create ...`。有两种方式可以创建新的执行线程，一种是继承 `Thread` 类，另一种是实现 `Runnable` 接口。

怎么去理解这个东西？我们先来看 `Thread` 类和 `Runnable` 接口的定义：

```java
public class Thread implements Runnable {
    // 省略无关代码
    
    private Runnable target;

    @Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }
}

@FunctionalInterface
public interface Runnable {
    
    public abstract void run();
}
```

`Runnable` 接口中的 `run` 方法抽象的是“可做的事情”，可将其称为任务。

`Thread` 类是对线程进行建模，一个 `Thread` 类的实例对象就是一个线程，线程启动后有自己的任务，用 `Runnable` 成员变量存储。

`Thread` 类实现了 `Runnable` 接口的 `run` 方法，用来驱动成员变量 `Runnable` 存储的任务的执行。线程 `start` 之后会自动调用 `Thread` 类的 `run` 方法。

所以问题不应该是创建线程有几种方式，而是任务的存储和驱动有几种方式。

## 第一种：继承 `Thread` 类

不使用 `Runnable` 成员变量存储，直接将任务告诉 `Thread` 类的 `run` 方法。

```java
@Slf4j
static class MyExtendsThread extends Thread {

    @Override
    public void run() {
        LOGGER.info("Create a thread by inheriting from the Thread class.");
    }
}

public static void main(String[] args) {
    // extends Thread
    new MyExtendsThread().start();
}
```

我们无法去修改 `Thread` 类的 `run` 方法，只能进行扩展增强（继承的方式）：继承 `Thread` 类后对 `run` 方法进行重写覆盖，将要执行的任务写在子类的 `run` 方法中。

这种方式没有用 `Thread` 类的成员变量 `Runnable` 存储任务，破坏了 `Thread` 类对线程的建模思想。

## 第二种：实现 `Runnable` 接口

将任务包装成 `Runnable` 对象，通过 `Thread` 类的有参构造器将任务传递给其 `Runnable` 成员变量进行存储。

```java
@Slf4j
static class MyImplRunnable implements Runnable {

    @Override
    public void run() {
        LOGGER.info("Create a thread by implementing the Runnable interface.");
    }
}

public static void main(String[] args) {
    // impl Runnable
    new Thread(new MyImplRunnable()).start();
}
```

所以，创建线程有几种方式这个问题，我给出的答案是一种：创建 `Thread` 类的对象。

不同的是如何去存储和驱动线程要执行的任务。

## 第三种：实现 `Callable` 接口

我们想在线程执行完任务之后具有返回值。

按照 `Thread` 类对线程的建模，我们需要将待执行的任务包装成一个 `Runnable` 对象交给 `Thread` 类的成员变量进行存储。

任务的驱动是由 `Thread` 类的 `run` 方法来做的，但这个方法没有返回值，我们也不能去直接调用这个 `run` 方法，否则就不是创建一个线程了。

所以我们应该在这个 `run` 方法中将返回值保存在某个地方，在将来的某个时刻再去获取这个返回值，但任务何时执行完我们无法得知，我们也不一定立即需要这个返回值，所以可以使用 `j.u.c` 包中的 `Future` 类，但它不是一个 `Runnable`，于是我们有 `RunnableFuture` 这个组合接口，并且在 `j.u.c` 包下有一个实现类 `FutureTask`。我们使用 `Callable` 接口抽象出具有返回值的事情，交给 `FutureTask` 的成员变量进行存储。因为 `FutureTask` 是一个 `Runnable`，符合 `Thread` 类对线程的建模，所以可以正常使用 `Thread` 类的 `run` 方法进行驱动，同时 `FutureTask` 是一个 `Future` 对象，我们可以获取到线程执行完 `Callable` 之后的返回值。简单地看下 `FutureTask` 类的 `run` 方法的具体实现：

```java
public void run() {
    if (state != NEW ||
        !UNSAFE.compareAndSwapObject(this, runnerOffset,
                                    null, Thread.currentThread()))
        return;
    try {
        Callable<V> c = callable;
        if (c != null && state == NEW) {
            V result;
            boolean ran;
            try {
                // 调用得到结果
                result = c.call();
                ran = true;
            } catch (Throwable ex) {
                result = null;
                ran = false;
                setException(ex);
            }
            if (ran)
                // 将结果进行存储
                set(result);
        }
    } finally {
        // runner must be non-null until state is settled to
        // prevent concurrent calls to run()
        runner = null;
        // state must be re-read after nulling runner to prevent
        // leaked interrupts
        int s = state;
        if (s >= INTERRUPTING)
            handlePossibleCancellationInterrupt(s);
    }
}

/** The result to return or exception to throw from get() */
private Object outcome; // non-volatile, protected by state reads/writes

protected void set(V v) {
    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {
        // 存储到成员变量outcome中
        outcome = v;
        UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state
        finishCompletion();
    }
}
```

主要逻辑很简单：获取成员变量 `Callable` 并调用其 `call` 方法执行任务得到返回值，然后存储到成员变量 `outcome` 中。所以取值的时候只需取这个 `outcome` 成员变量即可。

于是，就有了所谓的第三种创建线程的方式：

```java
static class MyCallableThread implements Callable<String> {

    @Override
    public String call() throws Exception {
        return "Create a thread by implementing the Callable interface.";
    }
}

public static void main(String[] args) throws Exception {
    // impl Callable
    FutureTask<String> ft = new FutureTask<>(new MyCallableThread());
    new Thread(ft).start();
    String res = ft.get();
    LOGGER.info("FutureTask.get(). res={}.", res);
}
```

实际上还是创建了一个 `Thread` 类对象，只是任务存储和驱动的方式变了。

## 第四种：使用线程池创建

先来看下如何使用线程池：

```java
public static void main(String[] args) throws Exception {
    // ExecutorService
    ExecutorService executorService = Executors.newFixedThreadPool(1);
    executorService.execute(new MyImplRunnable());
    Future<String> future = executorService.submit(new MyCallableThread());
    String futureRes = future.get();
    LOGGER.info("ExecutorService.submit(), futureRes={}.", futureRes);
}
```

通过 `JDK` 提供的工具类 `Executors` 的静态方法 `newFixedThreadPool` 创建固定线程数量的线程池，可以用线程池来执行 `Runnable` 任务，也可以往线程池中提交具有返回值的任务，会返回一个 `Future` 对象用来获取返回值。

线程池底层通过线程工厂创建线程，默认的线程工厂源码如下：

```java
static class DefaultThreadFactory implements ThreadFactory {
    private static final AtomicInteger poolNumber = new AtomicInteger(1);
    private final ThreadGroup group;
    private final AtomicInteger threadNumber = new AtomicInteger(1);
    private final String namePrefix;

    DefaultThreadFactory() {
        SecurityManager s = System.getSecurityManager();
        group = (s != null) ? s.getThreadGroup() :
                              Thread.currentThread().getThreadGroup();
        namePrefix = "pool-" +
                      poolNumber.getAndIncrement() +
                     "-thread-";
    }

    public Thread newThread(Runnable r) {
        Thread t = new Thread(group, r,
                              namePrefix + threadNumber.getAndIncrement(),
                              0);
        if (t.isDaemon())
            t.setDaemon(false);
        if (t.getPriority() != Thread.NORM_PRIORITY)
            t.setPriority(Thread.NORM_PRIORITY);
        return t;
    }
}
```

可以看到本质还是使用 `new Thread` 来创建线程。

## 第五种：使用定时器 `Timer` 类

`JDK` 定时器 `Timer` 可以创建定时执行任务的线程，使用方式如下：

```java
public static void main(String[] args) {
    Timer timer = new Timer();
    timer.schedule(new TimerTask() {
        @Override
        public void run() {
            System.out.println("use Timer to create a thread.");
        }
    }, 1L);
}
```

在 `Timer` 类中，有以下成员变量：

```java
public class Timer {
    
    private final TaskQueue queue = new TaskQueue();
    
    /**
     * The timer thread.
     */
    private final TimerThread thread = new TimerThread(queue);

    class TimerThread extends Thread {
        // 省略无关代码
    }
}
```

可以看到在 `Timer` 对象中包含一个成员变量 `TimerThread`，这个 `TimerThread` 类继承自 `Thread`，它的 `run` 方法是任务驱动的方式；而 `TimerTask` 类实现了 `Runnable` 接口，它被用来包装任务。`schedule` 方法用于提交任务至 `TaskQueue` 队列进行存储等待调度。

## 总结

至此，我们可以这样理解，本质上创建线程只有一种方式：创建 `Thread` 类的对象。其余方式均是在此之上的封装，改变任务存储和驱动的方式。

那么我们到底该选择哪种方式呢？

根据 `Thread` 类对线程的建模，对于一般的任务而言，我们应该将任务包装成 `Runnable` 或其子类对象，通过 `Thread` 类的有参构造器用 `Runnable` 成员变量进行存储，通过调用 `Thread` 类的 `start` 方法间接使用 `run` 方法驱动任务的执行。
